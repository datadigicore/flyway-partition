/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.flyway.partition;

import com.flyway.partition.model.Config;
import com.flyway.partition.validator.ConfigValidator;
import org.flywaydb.core.Flyway;
import org.flywaydb.core.api.configuration.FluentConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.YearMonth;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static net.logstash.logback.marker.Markers.append;

@SuppressWarnings({"PMD.UseProperClassLoader", "PMD.InvalidLogMessageFormat", "PMD.DataflowAnomalyAnalysis"})
public class App {
    private static final Logger logger = LoggerFactory.getLogger(App.class);

    private static final String PARTITION_RANGE_YEARLY = "yearly";
    private static final String PARTITION_RANGE_MONTHLY = "monthly";

    private static final int FIRST_MONTH_OF_YEAR_VALUE = 1;
    private static final int LAST_MONTH_OF_YEAR_VALUE = 12;

    public static void main(String[] args) throws IOException {
        InputStream fileConfig = args.length != 0
                ? new FileInputStream(args[0])
                : App.class.getClassLoader().getResourceAsStream("config.yml");

        logger.info("Load file configuration");
        try (fileConfig) {
            Yaml yaml = new Yaml(new Constructor(Config.class));
            Config config = yaml.load(fileConfig);

            boolean isValid = ConfigValidator.validate(config);
            if (!isValid) {
                return;
            }

            FluentConfiguration fluentConfiguration = Flyway.configure()
                    .baselineOnMigrate(true)
                    .table("flyway_partition_history")
                    .dataSource(
                            String.format(
                                    "jdbc:postgresql://%s:%s/%s",
                                    config.getDatabaseHost(),
                                    config.getDatabasePort(),
                                    config.getDatabaseName()
                            ),
                            config.getDatabaseUsername(),
                            config.getDatabasePassword()
                    );

            String[] tableNames = config.getPartitionTables().split(",");
            for (String tableName : tableNames) {
                createPartition(tableName, config, fluentConfiguration);
                dropPartition(tableName, config, fluentConfiguration);
            }
        }
    }

    private static void createPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        switch (config.partitionRange.toLowerCase(Locale.ROOT)) {
            case PARTITION_RANGE_YEARLY:
                createYearlyPartition(tableName, config, fluentConfiguration);
                break;
            case PARTITION_RANGE_MONTHLY:
            default:
                createMonthlyPartition(tableName, config, fluentConfiguration);
                break;
        }
    }

    private static void createYearlyPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        for (int i = 0; i <= Math.abs(config.getPartitionNumberOfFuture()); i++) {
            String partitionTableName = String.format("%s_y%s", tableName, YearMonth.now().getYear() + i);
            String partitionRangeStart = String.format("%s-01-01", YearMonth.now().getYear() + i);
            String partitionRangeFinish = String.format("%s-01-01", YearMonth.now().getYear() + i + 1);

            createPartitionPlaceholders(tableName, fluentConfiguration, partitionTableName, partitionRangeStart, partitionRangeFinish);
        }
    }

    private static void createMonthlyPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        int year = YearMonth.now().getYear();
        int month = YearMonth.now().getMonthValue();
        for (int i = 0; i <= Math.abs(config.getPartitionNumberOfFuture()); i++) {
            String partitionTableName = String.format("%s_y%sm%02d", tableName, year, month + i);
            String partitionRangeStart = String.format("%s-%02d-01", year, month + i);
            String partitionRangeFinish = String.format("%s-%02d-01", year, month + i + 1);

            if (month + i + 1 > LAST_MONTH_OF_YEAR_VALUE) {
                partitionRangeFinish = String.format("%s-%02d-01", year + 1, month + i + 1 - LAST_MONTH_OF_YEAR_VALUE);
            }

            if (month + i == LAST_MONTH_OF_YEAR_VALUE) {
                month = month - LAST_MONTH_OF_YEAR_VALUE;
                year++;
            }

            createPartitionPlaceholders(tableName, fluentConfiguration, partitionTableName, partitionRangeStart, partitionRangeFinish);
        }
    }

    private static void createPartitionPlaceholders(String tableName, FluentConfiguration fluentConfiguration, String partitionTableName, String partitionRangeStart, String partitionRangeFinish) {
        Map<String, String> map = new ConcurrentHashMap<>();

        map.put("tableName", tableName);
        map.put("partitionTableName", partitionTableName);
        map.put("partitionRangeStart", partitionRangeStart);
        map.put("partitionRangeFinish", partitionRangeFinish);

        logger.info(append("table_name", tableName)
                .and(append("partition_table_name", partitionTableName))
                .and(append("partition_range_start", partitionRangeStart))
                .and(append("partition_range_finish", partitionRangeFinish)), "Create partition");

        flywayMigrate("create", map, fluentConfiguration);
    }

    private static void dropPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        switch (config.partitionRange.toLowerCase(Locale.ROOT)) {
            case PARTITION_RANGE_YEARLY:
                dropYearlyPartition(tableName, config, fluentConfiguration);
                break;
            case PARTITION_RANGE_MONTHLY:
            default:
                dropMonthlyPartition(tableName, config, fluentConfiguration);
                break;
        }
    }

    private static void dropYearlyPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        for (int i = 1; i <= 1; i++) {
            String partitionTableName;

            partitionTableName = String.format("%s_y%s", tableName, YearMonth.now().getYear() - i - Math.abs(config.getPartitionNumberToRetain()));

            dropPartitionPlaceholders(tableName, fluentConfiguration, partitionTableName);
        }
    }

    private static void dropMonthlyPartition(String tableName, Config config, FluentConfiguration fluentConfiguration) {
        int year = YearMonth.now().getYear();
        int month = YearMonth.now().getMonthValue();
        for (int i = 1; i <= 1; i++) {
            String partitionTableName = String.format("%s_y%sm%02d", tableName, year, month - i - Math.abs(config.getPartitionNumberToRetain()));

            if (month - i == FIRST_MONTH_OF_YEAR_VALUE) {
                month = month + LAST_MONTH_OF_YEAR_VALUE;
                year--;
            }

            dropPartitionPlaceholders(tableName, fluentConfiguration, partitionTableName);
        }
    }

    private static void dropPartitionPlaceholders(String tableName, FluentConfiguration fluentConfiguration, String partitionTableName) {
        Map<String, String> map = new ConcurrentHashMap<>();

        map.put("tableName", tableName);
        map.put("partitionTableName", partitionTableName);

        logger.info(append("table_name", tableName)
                .and(append("partition_table_name", partitionTableName)), "Drop partition");

        flywayMigrate("drop", map, fluentConfiguration);
    }

    private static void flywayMigrate(String operationType, Map<String, String> map, FluentConfiguration fluentConfiguration) {
        Flyway flyway = fluentConfiguration.placeholders(map)
                .locations("db/partition/" + operationType)
                .load();

        flyway.repair();
        flyway.migrate();
    }
}
